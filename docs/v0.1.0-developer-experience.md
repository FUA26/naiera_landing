# v0.1.0: Developer Experience & Foundation

## Developer's Perspective

In this phase, I am laying the groundwork for a healthy codebase. A strong foundation is critical for long-term maintainability. My goal is to automate as much friction as possible: I don't want to argue about code style, I want the computer to fix it. I don't want to accidentally commit broken code, I want git hooks to stop me.

## Work Checklist

### 1. Absolute Imports

- **What**: configuring `@/` as an alias for the project root.
- **Why**: `../../../../components/Button` is unreadable and brittle. `@/components/Button` is clean and refactor-friendly.

### 2. VSCode Configuration

- **What**: Creating `.vscode/settings.json`, `.vscode/extensions.json`.
- **Why**: When a new developer joins the team (or I clone this on a new machine), I want VSCode to recommend the right extensions (ESLint, Tailwind, Prettier) and have the correct settings (format on save) automatically applied.

### 3. Linting & Formatting (ESLint + Prettier + Knip)

- **What**:
  - Setting up ESLint with strict rules (Next.js, Tailwind, and potentially an opinionated config like Antfu's).
  - Configuring Prettier for consistent line breaks and spacing.
  - Adding `knip` to find unused files and exports.
- **Why**: "Tabs vs Spaces" debates are a waste of time. Strict linting catches bugs before they run. Knip helps keep the codebase lean by identifying dead code.

### 4. Git Hooks (Lefthook + Commitizen)

- **What**:
  - **Lefthook**: Running `pnpm lint` and `pnpm type-check` on `pre-commit`.
  - **Commitizen**: enforcing Conventional Commits.
- **Why**: I want to guarantee that every commit on the `main` branch builds and passes linting. I also want semantic versioning to be easy later, which requires structured commit messages.
